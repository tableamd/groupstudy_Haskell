・Pattern matching の復習

パターンマッチングとは、あるデータが従うべきパターンを指定して、そのパターンに従ってデータを分解するために使うものである。Haskellだと数値、文字、リスト、タプルなどの多くのデータ型でパターンマッチにつかうことができる。

　例えば渡された数が7かどうかを調べる関数

1.	lucky :: (Integral a) => a -> String  
2.	lucky 7 = "LUCKY NUMBER SEVEN!"  
3.	lucky x = "Sorry, you're out of luck, pal!" 
7が渡された"7だよ"と表示されて、7以外の数(x)が渡されたときは"素晴らしく運がないな君は"と表示される(用は何にでも合致するパターン)

そして1~5が渡されたかどうかを確認する関数
パターンマッチなしだとif/then/elseを使う羽目になるが…

1.	sayMe :: (Integral a) => a -> String  
2.	sayMe 1 = "One!"  
3.	sayMe 2 = "Two!"  
4.	sayMe 3 = "Three!"  
5.	sayMe 4 = "Four!"  
6.	sayMe 5 = "Five!"  
7.	sayMe x = "Not between 1 and 5"  

パターンマッチ使えば簡単に書けます。
最後のパターンを最初に持ってくると、常に"Not between 1 and 5"を表示する関数になってしまうので注意(他のパターンに落ちなくなってしまう)








そしてnの階乗をパターンマッチングを使えば再帰的に定義することができます。
0の階乗を1と定義し、nの階乗の関数を書くと、

1.	factorial :: (Integral a) => a -> a  
2.	factorial 0 = 1  
3.	factorial n = n * factorial (n - 1) 

このようになりますね。

パターンマッチングも失敗したりするんです。次のような関数がそれです。

1.	charName :: Char -> String  
2.	charName 'a' = "Albert"  
3.	charName 'b' = "Broseph"  
4.	charName 'c' = "Cecil"  

普通に動きそうだけど予期していない値が入力されると…

1.	ghci> charName 'a'  
2.	"Albert"  
3.	ghci> charName 'b'  
4.	"Broseph"  
5.	ghci> charName 'h'  
6.	"*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName 

こんな感じでエラー吐いちゃいますよ。網羅的でないパターンとエラー吐いているので、パターンを作るときはすべてに合致するパターンを最後に入れておいてね。そうすればプログラムがクラッシュせずにすむからね。








・ほんへ

パターンマッチングはタプルで利用することができる。仮にあなたが2次元上の2つのベクトルを足し合わせる関数を作りましょう。2つのベクトルの足し算するとき、x成分とy成分をそれぞれ足し合わせます。ここでパターンマッチングを知らなかった場合こう書くだろう。

1.	addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
2.	addVectors a b = (fst a + fst b, snd a + snd b)


これでも動きますけど、でももっといい方法があるんですよ。パターンマッチングを使って書き換えていきますかね。

1.	addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
2.	addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)


こっちの方がわかりやすいよね。パラメータとなる2つのペアが引数となるのは保障されてるってこと。
Fstとsndはペアの要素を引き抜くものですね。しかしトリプルの場合どうなる？そういうのはないけど独自で定義をすることは可能です。

1.	first :: (a, b, c) -> a  
2.	first (x, _, _) = x  
3.	  
4.	second :: (a, b, c) -> b  
5.	second (_, y, _) = y  
6.	  
7.	third :: (a, b, c) -> c  
8.	third (_, _, z) = z  


この_はどうでもいいので使い捨ての変数を表すために使ってますよ

リスト内包表記でもパターンマッチが使えますよ。

1.	ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]  
2.	ghci> [a+b | (a,b) <- xs]  
3.	[4,7,6,8,11,4]  
リスト内包表記のパターンマッチは失敗したら次の要素に進みます。

普通のリストもパターンマッチで使えますよ。空リスト「」、または：を含むパターンと合致させることができる。ただし、[1,2,3]は1:2:3:[]の構文糖衣(読み書きしやすいために導入される構文)ということである。x:xsのようなパターンは、リストの先頭要素をxに縛り付け、残りをxsに縛り付ける。リストの要素が1つならxsは空のリストですよ。

ノート
x:xsというパターンは特に再帰関数と一緒によく使われている。しかし:を含むパターンは長さが1以上のリストにのみ合致しません。

もし3つの先頭要素を縛り付けたいなら、x:y:z:zsと書けばできますよ。


それじゃあ今覚えたパターンマッチを使って独自のhead関数を作りましょう。

1.	head' :: [a] -> a  
2.	head' [] = error "Can't call head on an empty list, dummy!"  
3.	head' (x:_) = x 

これをロードするとこう動きますよ。

1.	ghci> head' [4,5,6]  
2.	4  
3.	ghci> head' "Hello"  
4.	'H'

定義にあるように、複数の変数に束縛したいときは丸括弧で囲まないとシンタックスエラーを吐きますよ。

Errorという関数を使ってることにも気づいてください。Erroe関数は文字列を引数にとって、その文字列を使ってランタイムエラーを表示させる。これはプログラムをクラッシュさせるものなので、使うのはよろしくないですよ。まぁ空リストは受け取れないから多少はね？

そんじゃもう1つ、不便な英語形式であるリストの最初の要素を出力する関数を作ってみましょう

1.	tell :: (Show a) => [a] -> String  
2.	tell [] = "The list is empty"  
3.	tell (x:[]) = "The list has one element: " ++ show x  
4.	tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y  
5.	tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y 

この関数は空リスト、1つの要素、2つの要素、それ以上の要素をもつリストを管理しているので安全です(エラー吐かないよ)。(x:[])と(x:y:[])は、[x],[x,y]と書くこともできます。しかし(x:y:_)は角括弧を使って書き直すことはできない。このパターンは要素の長さが2以上のリストに合致するからやで。

私たちはすでにリストの内包表記を利用して、length関数を実装しました。それじゃ今からパターンマッチと再帰を少し使ってlength関数を作ってみましょう。

1.	length' :: (Num b) => [a] -> b  
2.	length' [] = 0  
3.	length' (_:xs) = 1 + length' xs  

さっき書いた階乗の関数と似てますね。まず空リストを0と定義します。次にリストを先頭と尾の部分に分解していき、リストを離れさせて2つのリストを取る。今私たちにとって先頭のリストが何かであるかはどうでもいいので、先頭を統一するために_を使う。また、私たちはリストのすべて可能なパターンを管理していたことに注意してください。最初のパターンが空リストと一致し、2つ目のパターンが空リストでないものと一致する。


例えば"ham"というリストを使ってlength'を呼び出したとき何が起きているかを確認しましょう。まず空リストであるかどうかを確認、まぁそんなことはありえないから次にパターンに行こう。次は先頭の要素を切り捨てることになり、長さは1 + length'  "am"となります。同じように続けていくと、1 + ( 1 + length' "m" )、1 + ( 1 + ( 1 + length' " " ) )となり、先頭要素が切り捨てられない空リストになるので、length' "" は0となる。
よって1 + ( 1 + ( 1 + 0) )となり、"ham"の長さは3となる。

次に和"sum"を実装してみましょう。空リストの合計が0であることはわかる。そして先頭部分と残りの部分の足し算がリストの合計であることもわかる。

1.	sum' :: (Num a) => [a] -> a  
2.	sum' [] = 0  
3.	sum' (x:xs) = x + sum' xs 

これをasパターンと呼ぶ。asパターンは、パターンに従って値を分解し、パターンマッチの対象になった値自信を参照したいときに使います。asパターンを作るときは、普通のパターンの前に名前と@を追加します。
例えば、xs@(x:y:ys)のようなasパターンを作りますよ。このパターンは、x:y:ysに合致するものとまったく同じものに合致しつつ、xsで元のリスト全体にアクセスすることもできる。x:y:ysとタイプしなくてもいいのよ。これが簡単な例です。

1.	capital :: String -> String  
2.	capital "" = "Empty string, whoops!"  
3.	capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]

ロードしてみましょう
1.	ghci> capital "Dracula"  
2.	"The first letter of Dracula is D" 
私たちは関数本体に再び全体を利用する必要があるとき、大きなパターンと合致する際にパターンの繰り返しを避けるためにasパターンを使います。



あと1つあってですね、パターンマッチでは++は使えないんですよ。(++は2つのリストをつなげる演算子)　例えば(xs ++ ys)に対して合致させようとしても、リストのどの部分をxsに合致させて、どの部分をysに合致させればいいかわからないわけですよ。(xs ++ [x,y,z])や(xs ++ [x])というパターンなら、リストの性質から合致できそうですけど実際そんな賢い合致はできませんよ。

・ガードガード





